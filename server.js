const express = require("express"); const cors = require("cors"); const helmet = require("helmet"); const WebSocket = require("ws"); const http = require("http"); const jwt = require("jsonwebtoken"); const bcrypt = require("bcryptjs"); const { v4: uuidv4 } = require("uuid"); require("dotenv").config(); const PORT = process.env.PORT || 3000; const JWT_SECRET = process.env.JWT_SECRET || "drilunia-secret-key-2024"; const app = express(); const server = http.createServer(app); const wss = new WebSocket.Server({ server }); app.use(helmet()); app.use(cors()); app.use(express.json()); const users = new Map(); const messages = new Map(); const wsConnections = new Map(); app.get("/health", (req, res) => { res.json({ status: "healthy", service: "Drilunia Backend", version: "1.0.0", timestamp: new Date().toISOString() }); }); app.post("/api/auth/register", async (req, res) => { try { const { email, password, username, displayName } = req.body; if (!email || !password || !username) { return res.status(400).json({ success: false, message: "Email, password y username son requeridos" }); } if (users.has(email)) { return res.status(409).json({ success: false, message: "El usuario ya existe" }); } const hashedPassword = await bcrypt.hash(password, 12); const user = { id: uuidv4(), email, username, displayName: displayName || username, password: hashedPassword, avatar: null, emailVerified: false, createdAt: new Date() }; users.set(email, user); const accessToken = jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: "24h" }); res.status(201).json({ success: true, message: "Usuario registrado exitosamente", data: { user: { id: user.id, email: user.email, username: user.username, displayName: user.displayName }, tokens: { accessToken } } }); } catch (error) { res.status(500).json({ success: false, message: "Error interno del servidor" }); } }); app.post("/api/auth/login", async (req, res) => { try { const { email, password } = req.body; if (!email || !password) { return res.status(400).json({ success: false, message: "Email y password son requeridos" }); } const user = users.get(email); if (!user) { return res.status(401).json({ success: false, message: "Credenciales inválidas" }); } const isValidPassword = await bcrypt.compare(password, user.password); if (!isValidPassword) { return res.status(401).json({ success: false, message: "Credenciales inválidas" }); } const accessToken = jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: "24h" }); res.json({ success: true, message: "Login exitoso", data: { user: { id: user.id, email: user.email, username: user.username, displayName: user.displayName }, tokens: { accessToken } } }); } catch (error) { res.status(500).json({ success: false, message: "Error interno del servidor" }); } }); app.get("/api/ice", (req, res) => { res.json({ success: true, data: { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }] } }); }); wss.on("connection", (ws) => { console.log("Nueva conexión WebSocket"); ws.on("message", (message) => { try { const data = JSON.parse(message); console.log("Mensaje WebSocket recibido:", data); } catch (error) { console.error("Error procesando mensaje:", error); } }); }); server.listen(PORT, () => { console.log(`🚀 Servidor Drilunia iniciado en puerto ${PORT}`); console.log(`📡 API disponible en http://localhost:${PORT}/api`); console.log(`🔌 WebSocket disponible en ws://localhost:${PORT}`); console.log(`💚 Health check en http://localhost:${PORT}/health`); });
